-- clustering_plot_tuModelo_v2.kf
-- Versión ajustada para intentar separar en dos clústeres

import geshaDeep;
import plot;

-- ================================================
-- 1) Datos 2D “hardcodeados”
-- ================================================
List[List[FLOAT]] datos = [
    [1.0, 2.0],
    [1.5, 1.8],
    [5.0, 8.0],
    [8.0, 8.0],
    [1.0, 0.6],
    [9.0, 11.0]
];

List[INT] y_dummy = [];

-- ================================================
-- 2) Creamos el modelo clustering
-- ================================================
GESHA modelo = geshaDeep.clustering();

-- 2.1 Capa oculta 1: 4 neuronas, ReLU, input_shape = [2], semilla = 12
GESHA capa1 = geshaDeep.create_dense(
    8,         -- 4 neuronas en primera capa oculta
    "relu",    
    [2],       -- entrada 2D
    0.0,       -- sin L2
    12         -- semilla distinta
);
modelo.add(capa1);

-- 2.2 Capa oculta 2: 4 neuronas, ReLU, hereda salida capa1, semilla = 99
GESHA capa1b = geshaDeep.create_dense(
    4,        
    "relu",   
    [],       -- se infiere (4) automáticamente
    0.0,
    99        -- otra semilla
);
modelo.add(capa1b);

-- 2.3 Capa salida: 2 neuronas (k=2), softmax, semilla = 42
GESHA capa2 = geshaDeep.create_dense(
    2, "softmax", [], 0.0, 42
);
modelo.add(capa2);

-- 2.4 Compilamos: Adam con lr=0.0005, pérdida = categorical_crossentropy
geshaDeep.compile(modelo, "adam", "categorical_crossentropy", []);
-- Ajustamos lr muy bajo para evitar colapso inmediato
geshaDeep.set_lr(modelo, 0.0005);

-- ================================================
-- 3) Entrenamos: epochs = 300, batch_size = 2
-- ================================================
modelo.fit(datos, y_dummy, 300, 2);

-- ================================================
-- 4) Predicción y separación en listas X0,Y0 y X1,Y1
-- ================================================
List[FLOAT] X0 = [];
List[FLOAT] Y0 = [];
List[FLOAT] X1 = [];
List[FLOAT] Y1 = [];

List[INT] indices = [0,1,2,3,4,5];
for (i in indices):
    List[FLOAT] punto = datos[i];
    List[FLOAT] probs = modelo.predict(punto);
    show(probs);  -- imprimo probabilidades para ver evolución
    
    FLOAT p0 = probs[0];
    FLOAT p1 = probs[1];
    INT etiqueta;
    if (p0 >= p1):
        etiqueta = 0;
    else:
        etiqueta = 1;
    ;
    
    FLOAT xi = punto[0];
    FLOAT yi = punto[1];
    if (etiqueta == 0):
        append(X0, xi);
        append(Y0, yi);
    else:
        append(X1, xi);
        append(Y1, yi);
    ;
;

-- ================================================
-- 5) Cálculo de centros de cada clúster (sin ternario)
-- ================================================
FLOAT sumx0 = 0.0; FLOAT sumy0 = 0.0; INT count0 = 0;
FLOAT sumx1 = 0.0; FLOAT sumy1 = 0.0; INT count1 = 0;

for (i in indices):
    List[FLOAT] punto = datos[i];
    List[FLOAT] probs = modelo.predict(punto);
    FLOAT p0 = probs[0];
    FLOAT p1 = probs[1];
    INT etiqueta;
    if (p0 >= p1):
        etiqueta = 0;
    else:
        etiqueta = 1;
    ;
    FLOAT xi = punto[0];
    FLOAT yi = punto[1];
    if (etiqueta == 0):
        sumx0 = sumx0 + xi;
        sumy0 = sumy0 + yi;
        count0 = count0 + 1;
    else:
        sumx1 = sumx1 + xi;
        sumy1 = sumy1 + yi;
        count1 = count1 + 1;
    ;
;

FLOAT cx0;
if (count0 == 0):
    cx0 = 0.0;
else:
    cx0 = sumx0 / count0;
;

FLOAT cy0;
if (count0 == 0):
    cy0 = 0.0;
else:
    cy0 = sumy0 / count0;
;

FLOAT cx1;
if (count1 == 0):
    cx1 = 0.0;
else:
    cx1 = sumx1 / count1;
;

FLOAT cy1;
if (count1 == 0):
    cy1 = 0.0;
else:
    cy1 = sumy1 / count1;
;

List[FLOAT] CX = [cx0, cx1];
List[FLOAT] CY = [cy0, cy1];

-- ================================================
-- 6) Listas de pares (para plot.graph)
-- ================================================
List[List[FLOAT]] pares0 = [];
for (i in range(0, len(X0))):
    append(pares0, [X0[i], Y0[i]]);
;

List[List[FLOAT]] pares1 = [];
for (i in range(0, len(X1))):
    append(pares1, [X1[i], Y1[i]]);
;

List[List[FLOAT]] centros = [];
for (i in range(0, len(CX))):
    append(centros, [CX[i], CY[i]]);
;

-- ================================================
-- 7) Graficamos resultados
-- ================================================
plot.figure();
plot.title("Clustering k-means (k=2) ― GeshaDeep (2 capas de 4 → 4, lr=0.0005)");
plot.xlabel("X");
plot.ylabel("Y");
plot.grid(True);

-- cluster 0 en rojo
if (len(pares0) > 0):
    plot.pointColor("red");
    plot.pointSize(6);
    plot.graph(pares0, "point");
;
-- cluster 1 en verde
if (len(pares1) > 0):
    plot.pointColor("green");
    plot.pointSize(6);
    plot.graph(pares1, "point");
;
-- centros en negro (punto más grande)
if (len(centros) > 0):
    plot.pointColor("black");
    plot.pointSize(8);
    plot.graph(centros, "point");
;

plot.legend("red: clúster 0 ; green: clúster 1 ; black: centros");
plot.render();